# The results looks like forward stepwise regression
# through 6 variables. All the previously selected
# variables are included
#
# In comparing the the 7 variable model
# to the six variable model
# which variables were added and which
# were dropped?
regfit.full=regsubsets(Salary~.,data=Hitters,
nvmax=19)
reg.summary=summary(regfit.full)
names(reg.summary)
# R-squared in percent
round( 100*reg.summary$rsq, 1)
# Extra:  for a comparison
# RSS is the residual sum of squares
# MSE = RSS/n
# Full model MSE
model10.MSE = reg.summary$rss[10]/nrow(Hitters)
model10.MSE
# 2.3 Four plots per page showing 4 criteria
#     and with dots indicating best models
#
# Uses R base level graphics
# mfrow allocates space putting plot
# panels in row and columns
# Each plot() command advances to the
# next plot.  The points() function
# add points to the currently
# active plot
windows(width=6, height=6)
par(mfrow=c(2,2))
xlab="Number of Variable"
# 1st row 1st  column
plot(reg.summary$rss,xlab=xlab,
ylab="RSS",type="l")
# 1st row 2nd  column
plot(reg.summary$adjr2,xlab=xlab,
ylab="Adjusted RSq",type="l")
loc <- which.max(reg.summary$adjr2)
loc
points(loc,reg.summary$adjr2[loc],
col="red",cex=2,pch=20)
# 2nd row 1st column
plot(reg.summary$cp,xlab=xlab,
ylab="Cp",type='l')
loc <- which.min(reg.summary$cp)
loc
points(loc,reg.summary$cp[loc],
col="red",cex=2,pch=20)
# 2nd row 2nd column
plot(reg.summary$bic,xlab=xlab,
ylab="BIC",type='l')
loc <-  which.min(reg.summary$bic)
loc
points(loc,reg.summary$bic[loc],
col="red",cex=2,pch=20)
# Plot redesign comments
# Putting multiple panels in a plot with
# mfrow() has been convenient for many
# people over the years but often wastes
# space.  If the window height is
# small the limited y-axis resolution may
# result in unreadable y-axis tick mark
# labels.
#
# There is common x-axis. There could be 4
# vertically aligned panels with common x-axis
# grid lines.  Putting  grid line labels at the
# bottom of the stack would suffice.
#
# We could keep the two column design and
# remove all the wasted space better the
# two rows.
# Regression comments:
# The BIC criterion has a minimum at
# six variables. The BIC is often chosen
# the preferred model selection criterion.
#
# The adjusted R-squared has a minimum at
# 11 variables but is not increasing very
# quickly after six variables.  It seems
# reasonable to consider a six variable model
# and look at the coefficients.
coef(regfit.full,6)
# 2.4 Redesign comments for ISLR plots
#     showing the models from best
#     at the top to the worst at bottom
#     for the given criterion
#
#     Plot size matters for readability.
#
#     The color encoding have poor
#     perceptual accuracy of extraction
#     The chosen mapping of values to
#     to gray provide the best gray
#     level discrimination for the
regfit.full=regsubsets(Salary~.,Hitters)
reg.summary <- summary(regfit.full)
reg.summary
mat <- reg.summary$outmat
mat
rownames(mat)
mat[1,]
rownames(mat) <- 1:nrow(mat)
mat<- mat[1:8,]
mat
matL <- ifelse(mat==" ",FALSE,TRUE)
# Transpose the matrix
matLT <- t(matL)
matLT
usedVar <- apply(matLT,1,any)
matLT <-matLT[usedVar,]
matLT
# Sort the remaining variables by
# the number of time used rows
usedN <- apply(matLT,1,sum)
matLT <- matLT[order(usedN,decreasing=TRUE),]
# Find the number of rows and
# columns used to set up
# axes for the plot
nModel <- ncol(matLT)
nVar <- nrow(matLT)
rx <- c(.5,nModel+.5)
ry <- c(.5,nVar+.5)
## Select and run lines
#  from here to
#  ##End==============
windows(width=4.5,height=4)
# Set the plot margins in inches
# bottom, left, top, right
# and save the previous setting
oldPar <- par(mai=c(.2,1.3,1.1,.2))
# Just setup the plot
plot(rx,ry,type='n',axes=FALSE,
xlab='', ylab='', cex=.85,
main=paste("Best 8 Salary Models",
"with a Mean and 1 to 8 Variables",sep="\n"))
# Construct coordinates for rows
# and columns. Omit those with
# FALSE in the matrix and
# plot the remaining points
xy <- expand.grid(list(x=1:nModel,y=nVar:1))
xy <- xy[t(matLT),]
points(xy$x,xy$y,pch=21,bg="red",cex=1.5)
# Add grid lines for perceptual grouping
hline <- seq(3.5,nVar,by=3)
vline <- seq(3.5,nModel,by=3)
abline(h=hline, col=gray(.8))
abline(v=vline, col=gray(.8))
box()  #  draw the plot border
# put labels in the plot margins
mtext(rownames(matLT),side=2,at=nVar:1,
line=.3,las=1)
newColNam = substring(colnames(matLT),1,2)
mtext(newColNam,at=1:nModel, side=3)
# reset the device plot margin
par(oldPar)
xy <- xy[t(matLT),]
coef(regfit.full,6)
mat <- reg.summary$outmat
mat
rownames(mat)
#   minor edits by Daniel Carr
#   minor edits by Daniel Carr
install.packages(c("cluster", "codetools", "colorspace", "evaluate", "mgcv", "R6", "reshape2", "shiny", "splines2", "stringi", "survival"))
install.packages("devtools")
load("/Users/hp/Documents/GMU/CSI773/ShinySubset/CensusMap/R3_2.RData")
library(shiny)
runApp("/Users/hp/Documents/GMU/CSI773/ShinySubset") # just a path to the folder
runApp("/Users/hp/Documents/GMU/CSI773/ShinySubset/CensusMap") # just a path to the folder
install.packages("maps")
library("maps", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library(shiny)
runApp("/Users/hp/Documents/GMU/CSI773/ShinySubset/CensusMap") # just a path to the folder
install.packages("mapproj")
library(shiny)
runApp("/Users/hp/Documents/GMU/CSI773/ShinySubset/CensusMap") # just a path to the folder
library(shiny)
runApp("/Users/hp/Documents/GMU/CSI773/ShinySubset/mat4BinSmooth") # just a path to the folder
install.packages("elastic")
connect()
connection()
Search(index="plos", type="article", sort="title", q="antibody", size=1)$hits$hits
library("elastic", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("elastic")
Search(index="plos", type="article", sort="title", q="antibody", size=1)$hits$hits
Search(index="plos", type="article", sort="title", q="antibody", size=1)$hits$hits
connect()
Search(index="plos", type="article", sort="title", q="antibody", size=1)$hits$hits
Search(index="cbp", type="wait-times")$hits$hits
shiny::runApp('workbench/projects/skunk/shiny/r-data/wait-times/CensusMap')
install.packages("leaflet")
ui <- bootstrapPage(
tags$style(type="text/css", "html, body {width:100%;height:100%}"),
leafletOutput("Map", width="100%", height="100%"),
absolutePanel(top=10, right=10,
selectInput("location", "Community", c("", locs$loc), selected=""),
conditionalPanel("input.location !== null && input.location !== ''",
actionButton("button_plot_and_table", "View Plot/Table", class="btn-block"))
)
)
install.packages("leaflet")
ui <- bootstrapPage(
tags$style(type="text/css", "html, body {width:100%;height:100%}"),
leafletOutput("Map", width="100%", height="100%"),
absolutePanel(top=10, right=10,
selectInput("location", "Community", c("", locs$loc), selected=""),
conditionalPanel("input.location !== null && input.location !== ''",
actionButton("button_plot_and_table", "View Plot/Table", class="btn-block"))
)
)
install.packages("leaflet")
ui <- bootstrapPage(
tags$style(type="text/css", "html, body {width:100%;height:100%}"),
leafletOutput("Map", width="100%", height="100%"),
absolutePanel(top=10, right=10,
selectInput("location", "Community", c("", locs$loc), selected=""),
conditionalPanel("input.location !== null && input.location !== ''",
actionButton("button_plot_and_table", "View Plot/Table", class="btn-block"))
)
)
server <- function(input, output, session) {
acm_defaults <- function(map, x, y) addCircleMarkers(map, x, y, radius=6, color="black", fillColor="orange", fillOpacity=1, opacity=1, weight=2, stroke=TRUE, layerId="Selected")
output$Map <- renderLeaflet({
leaflet() %>% setView(lon, lat, 4) %>% addTiles() %>%
addCircleMarkers(data=locs, radius=6, color="black", stroke=FALSE, fillOpacity=0.5, group="locations", layerId = ~loc)
})
observeEvent(input$Map_marker_click, { # update the map markers and view on map clicks
p <- input$Map_marker_click
proxy <- leafletProxy("Map")
if(p$id=="Selected"){
proxy %>% removeMarker(layerId="Selected")
} else {
proxy %>% setView(lng=p$lng, lat=p$lat, input$Map_zoom) %>% acm_defaults(p$lng, p$lat)
}
})
observeEvent(input$Map_marker_click, { # update the location selectInput on map clicks
p <- input$Map_marker_click
if(!is.null(p$id)){
if(is.null(input$location) || input$location!=p$id) updateSelectInput(session, "location", selected=p$id)
}
})
observeEvent(input$location, { # update the map markers and view on location selectInput changes
p <- input$Map_marker_click
p2 <- subset(locs, loc==input$location)
proxy <- leafletProxy("Map")
if(nrow(p2)==0){
proxy %>% removeMarker(layerId="Selected")
} else if(length(p$id) && input$location!=p$id){
proxy %>% setView(lng=p2$lon, lat=p2$lat, input$Map_zoom) %>% acm_defaults(p2$lon, p2$lat)
} else if(!length(p$id)){
proxy %>% setView(lng=p2$lon, lat=p2$lat, input$Map_zoom) %>% acm_defaults(p2$lon, p2$lat)
}
})
}
shinyApp(ui, server)
library("leaflet", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
ui <- bootstrapPage(
tags$style(type="text/css", "html, body {width:100%;height:100%}"),
leafletOutput("Map", width="100%", height="100%"),
absolutePanel(top=10, right=10,
selectInput("location", "Community", c("", locs$loc), selected=""),
conditionalPanel("input.location !== null && input.location !== ''",
actionButton("button_plot_and_table", "View Plot/Table", class="btn-block"))
)
)
server <- function(input, output, session) {
acm_defaults <- function(map, x, y) addCircleMarkers(map, x, y, radius=6, color="black", fillColor="orange", fillOpacity=1, opacity=1, weight=2, stroke=TRUE, layerId="Selected")
output$Map <- renderLeaflet({
leaflet() %>% setView(lon, lat, 4) %>% addTiles() %>%
addCircleMarkers(data=locs, radius=6, color="black", stroke=FALSE, fillOpacity=0.5, group="locations", layerId = ~loc)
})
observeEvent(input$Map_marker_click, { # update the map markers and view on map clicks
p <- input$Map_marker_click
proxy <- leafletProxy("Map")
if(p$id=="Selected"){
proxy %>% removeMarker(layerId="Selected")
} else {
proxy %>% setView(lng=p$lng, lat=p$lat, input$Map_zoom) %>% acm_defaults(p$lng, p$lat)
}
})
observeEvent(input$Map_marker_click, { # update the location selectInput on map clicks
p <- input$Map_marker_click
if(!is.null(p$id)){
if(is.null(input$location) || input$location!=p$id) updateSelectInput(session, "location", selected=p$id)
}
})
observeEvent(input$location, { # update the map markers and view on location selectInput changes
p <- input$Map_marker_click
p2 <- subset(locs, loc==input$location)
proxy <- leafletProxy("Map")
if(nrow(p2)==0){
proxy %>% removeMarker(layerId="Selected")
} else if(length(p$id) && input$location!=p$id){
proxy %>% setView(lng=p2$lon, lat=p2$lat, input$Map_zoom) %>% acm_defaults(p2$lon, p2$lat)
} else if(!length(p$id)){
proxy %>% setView(lng=p2$lon, lat=p2$lat, input$Map_zoom) %>% acm_defaults(p2$lon, p2$lat)
}
})
}
shinyApp(ui, server)
ui <- bootstrapPage(
tags$style(type="text/css", "html, body {width:100%;height:100%}"),
leafletOutput("Map", width="100%", height="100%"),
absolutePanel(top=10, right=10,
selectInput("location", "Community", c("", locs$loc), selected=""),
conditionalPanel("input.location !== null && input.location !== ''",
actionButton("button_plot_and_table", "View Plot/Table", class="btn-block"))
)
)
shinyApp(ui, server)
library(shiny)
library(dplyr)
library(leaflet)
source('workbench/projects/skunk/shiny/r-data/wait-times.R')
runApp('workbench/projects/skunk/shiny/r-data/wait-times')
runApp('workbench/projects/skunk/shiny/r-data/wait-times')
shiny::runApp('workbench/projects/skunk/shiny/r-data/wait-times')
runApp('workbench/projects/skunk/shiny/r-data/wait-times')
install.packages(c("BH", "colorspace", "ggplot2", "git2r", "htmlwidgets", "knitr", "mgcv", "Rcpp", "scales", "SparseM", "yaml"))
library(MASS)
library(rgl)
heptathlon = read.csv(file="heptathlon.csv",row.names=1)
heptathlon
setwd("~/Documents/GMU/CSI773/Week 10/Principal Components")
heptathlon = read.csv(file="heptathlon.csv",row.names=1)
heptathlon
hepDat = heptathlon[,-ncol(heptathlon)]
The values for hurdles, run200m and run800m are in seconds
The values are highjump, shot, long jump and javelin are meters
We can look the data with a scatterplot matrix
windows(width=7,height=7)
nam <- c("Hurdles\nSeconds","Highjump\nMeters","Shotput\nMeters",
"Run200m\nSeconds","Longjump\nMeters","Javelin\nMeters",
"Run800m\nSeconds")
myPanelSmooth = function(x,y,...)panel.smooth(x,y,lwd=3,col.smooth='red',...)
pairs(hepDat,lab=nam, panel=myPanelSmooth,pch=21,cex=1.5,
col=rgb(0,.6,1),bg=rgb(0,.6,1),gap=0,las=1)
plot(hepDat[c(1,7)],pch=16,col='blue',cex=1.2,las=1)
identify(heptathlon[,1],heptathlon[,7],lab=row.names(heptathlon))
identify(heptathlon[,1],heptathlon[,7],lab=row.names(heptathlon))
plot(hepDat[c(1,7)],pch=16,col='blue',cex=1.2,las=1)
identify(heptathlon[,1],heptathlon[,7],lab=row.names(heptathlon))
hepDat$hurdles=max(hepDat$hurdles)-hepDat$hurdles
hepDat$run200m=max(hepDat$run200m)-hepDat$run200m
hepDat$run800m=max(hepDat$run800m)-hepDat$run800m
heptPca = prcomp(hepDat,scale=TRUE)
heptPca$center # means of the variables
heptPca$scale  # standard deviation of the variables
heptPca$x      # principal components
heptPca$sdev   # standand deviations of the principal components
round(heptPca$rotation,2)
## Run
names(heptPca$sdev) = paste('Comp',1:length(heptPca$sdev),sep='')
plot(heptPca)
heptVar = heptPca$sdev**2
100*cumsum(heptVar)/sum(heptVar)
## End
plot(heptathlon$score,-heptPca$x[,1],las=1,pch=21,bg="red",
xlab="Official Score",ylab="First Principal Component",
main="Comparing Scores and First Principal Component")
correl = cor(-heptPca$x[,1],heptathlon$score)
xloc = mean(par()$usr[1:2])
text(xloc,4,paste("Correlation =",round(correl,2)),adj=.5,cex=1.1)
states=row.names(USArrests)
states
names(USArrests)
head(USArrests)
colMeans(USArrests)
apply(USArrests, 2, var)
pr.out=prcomp(USArrests, scale=TRUE)
names(pr.out)
pr.out$center
pr.out$scale
pr.out$rotation
dim(pr.out$x)
biplot(pr.out, scale=0,las=1)
pr.out$rotation=-pr.out$rotation
pr.out$x=-pr.out$x
biplot(pr.out, scale=0)
pr.out$sdev
pr.var=pr.out$sdev^2
pr.var
pve=pr.var/sum(pr.var)
biplot(pr.out, scale=0,las=1)
biplot(pr.out, scale=0,las=1)
pr.out$rotation=-pr.out$rotation
pr.out$x=-pr.out$x
biplot(pr.out, scale=0)
pr.out$sdev
pr.var=pr.out$sdev^2
pr.var
pve=pr.var/sum(pr.var)
pve
x = 1:length(pve)
qplot(x,pve, xlab="Principal Component",
ylab="Proportion of Variance Explained",
main="US Arrests By State",ylim=c(0,1)) +
geom_line()+geom_point(shape=21,fill="red",cex=3)
qplot(x,cumsum(pve), xlab="Principal Component",
ylab="Cumulative Proportion of Variance Explained",
main="US Arrests By State",ylim=c(0,1))+
geom_line()+geom_point(shape=21,fill="red",cex=3)
x = 1:length(pve)
qplot(x,pve, xlab="Principal Component",
ylab="Proportion of Variance Explained",
main="US Arrests By State",ylim=c(0,1)) +
geom_line()+geom_point(shape=21,fill="red",cex=3)
load(ggplot2)
load(ggplot)
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
qplot(x,pve, xlab="Principal Component",
ylab="Proportion of Variance Explained",
main="US Arrests By State",ylim=c(0,1)) +
geom_line()+geom_point(shape=21,fill="red",cex=3)
qplot(x,cumsum(pve), xlab="Principal Component",
ylab="Cumulative Proportion of Variance Explained",
main="US Arrests By State",ylim=c(0,1))+
geom_line()+geom_point(shape=21,fill="red",cex=3)
library(faraway)
install.packages("faraway")
data(orings)
library(faraway)
data(orings)
2. Space shuttle O-ring seals data and the
orings
3. Regression Models for Binomial Data
With a simple regression model in mind
a first thought might be to consider a model
of the form
p[i] = a + b * x[i] + e [i]
for the ith mission where
linearModel = lm(damage/6 ~ temp,data=orings)
summary(linearModel)
logitModel =
glm(cbind(damage,6-damage) ~ temp,
family=binomial, data = orings)
summary(logitModel)
probitModel =
glm(cbind(damage,6-damage) ~ temp,
family=binomial(probit),data=orings)
summary(probitModel)
6. Plots of fitted values
windows()
plot(damage/6~temp,orings,xlim=c(25,85),ylim=c(0,1),las=1,
xlab="Temperature (Degrees Fahrenheit)", ylab="Damage Probability",
pch=21,bg="red",col="red",
main="O-ring Models\nLinear:Black, Probit:Blue, Logit:Red")
tempGrid = 25:85
a=coef(linearModel)
lines(tempGrid,a[1]+a[2]*tempGrid,col="black",lwd=2)
a=coef(probitModel)
lines(tempGrid,pnorm(a[1]+a[2]*tempGrid),col="blue",lwd=2)
a = coef(logitModel)
lines(tempGrid,ilogit(a[1]+a[2]*tempGrid),col="red",lwd=4)
setwd("~/Documents/GMU/CSI773/Week 9/Micromap/Linked Micromap Introduction")
library(micromapST)
objects(pos=2)
head(stateNamesFips)
Note that the microFull2Ab conversion function defined in
library(shiny); source('~/workbench/projects/skunk/shiny/r-data/wait-times.R')
source('~/workbench/projects/skunk/shiny/r-data/wait-times.R')
source('~/workbench/projects/skunk/shiny/r-data/wait-times.R')
runApp('~/workbench/projects/skunk/shiny/r-data/wait-times')
library(ggplot2)
wh<-read.table(file='WaitTimesPerHour.csv',sep=',',header=TRUE)
attach(wh)
names(wh)
wd<-read.table(file='WaitTimesPerDay.csv',sep=',',header=TRUE)
attach(wd)
names(wd)
setwd("~/workbench/projects/skunk/shiny/r-data/wait-times")
library(ggplot2)
wh<-read.table(file='WaitTimesPerHour.csv',sep=',',header=TRUE)
attach(wh)
names(wh)
wd<-read.table(file='WaitTimesPerDay.csv',sep=',',header=TRUE)
attach(wd)
names(wd)
ggplot(wd, aes(x = AvgWait, fill = Airport)) +
geom_histogram(data = wd, fill = "grey", alpha = .5) +
geom_histogram(colour = "black") +
facet_wrap(~ Airport) +
guides(fill = FALSE) +  # to remove the legend
theme_bw()              # for clean look overall
ggplot(wd, aes(x = MaxWait, fill = Airport)) +
geom_histogram(data = wd, fill = "grey", alpha = .5) +
geom_histogram(colour = "black") +
facet_wrap(~ Airport) +
guides(fill = FALSE) +  # to remove the legend
theme_bw()              # for clean look overall
ggplot(wd, aes(x =Booths , y =AvgWait, colour = Airport)) +
geom_point(data = wd, colour = "grey", alpha = .2) +
geom_point() +
facet_wrap(~ Airport) +
guides(colour = FALSE) +
theme_bw()
View(wh)
ggplot(wh, aes(x = AvgWait, y= Count)
g<- ggplot(wh, aes(x = AvgWait, y= Count)
g <- ggplot(wh, aes(x = AvgWait, y= Count))
g
g <- ggplot(wh, aes(x = AvgWait, y= Count)) + geom_point(aes(color=Hour))
g
g <- ggplot(wh, aes(x = AvgWait, y= Count)) + geom_point(aes(color=Hour)) + facet_wrap(~ Airport)
g
runApp()
runApp()
runApp()
runApp()
runApp()
